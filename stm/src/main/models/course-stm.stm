
// TO ASK: can we leave entities/attributes that are protected by GUI on fullAccess?

role STUDENT {
    Person{
        read(name) constrainedBy [self.role = Role::PROFESSOR or self = caller]
        update(name) constrainedBy [self = caller]
        read(surname) constrainedBy [self.role = Role::PROFESSOR or self = caller]     
        update(surname) constrainedBy [self = caller]
        read(username) constrainedBy [self = caller]
        read(password) constrainedBy [self = caller]
        update(password) constrainedBy [self = caller]
        read(role) constrainedBy [self.role = Role::PROFESSOR or self = caller]    
        read(belongs) constrainedBy [self.role = Role::PROFESSOR or self = caller]

        add(currCourses) constrainedBy [ self = caller and
                    (target.course.currStudents->size() <= target.course.maxCapacity)]  // if we use '<', maximum "maxCapacity-1" is allowed

        read(currCourses)
        read(pastCourses)
    }
    Course{
       read(name)
       read(maxCapacity)
       read(belongingTo) // Department
       read(professor)

       // i think students arent allowed to see the current number of students
       //read(currStudents)
       add(currStudents) constrainedBy [
            self.currStudents.student->excludes(caller) and
            self.pastStudents.student->excludes(caller)]
    }
    Department{
        read(name)
    }
    FinalGrade{
        read(value)
        read(student)
        read(course)
    }
    ProvisionalGrade{
        create
        read(course)
        read(student)
        update(student)
    }
    TeachRequest{
                
    }
}
role STAFF {
    Person{
        read(name)
        update(name) constrainedBy [self = caller]
        read(surname)
        update(surname) constrainedBy [self = caller]
        read(username) constrainedBy [self = caller]
        read(password) constrainedBy [self = caller]
        update(password) constrainedBy [self = caller]
        read(role)
        read(belongs)

        read(currCourses)
        read(pastCourses)
    }
    Course{
        read(name)
        read(maxCapacity)
        read(professor)
        read(belongingTo) // Department
        
        read(staff) constrainedBy [self.staff->includes(caller)]    // It is not necessary to make professors invisible, as any staff member can see the administering professor of each course
        read(currStudents) constrainedBy [self.staff->includes(caller)]
        read(pastStudents) constrainedBy [self.staff->includes(caller)]

    }
    Department{
        read(name)
    }
    FinalGrade{
        read(student), read(course), read(value) constrainedBy [
            caller.teaches->includes(self.course)]       
    }
    ProvisionalGrade{
        read(student), read(course), read(value),
        update(value) constrainedBy [
            caller.teaches->includes(self.course)]
    }
    TeachRequest{        
    }
}
role TA extends STAFF {
    Person{
         
    }
    Course{

    }
    Department{
       
    }
    FinalGrade{
   
    }
    ProvisionalGrade{

    }
    TeachRequest{
        create
        update(ta)        
        // Professor is included in staff => we need to subtract with 1
        // If TA is already teaching this course, no request for this course can be send
        // If TA already has a request pending for this course, TA cannot send another request
        update(course) constrainedBy [(value.staff->size()-1 <= value.maxCapacity.div(20)) and
               value.staff->excludes(caller) and
               value.taRequests.ta->excludes(caller)]        
    }


}
role PROFESSOR extends STAFF {
    Person{
        add(administers), add(teaches) constrainedBy [self = caller]

        // Delete course
        remove(currCourses) constrainedBy [target.course.professor = caller]
        remove(pastCourses) constrainedBy [target.course.professor = caller]

        remove(courseRequests) constrainedBy [target.course.professor = caller]

        remove(teaches) constrainedBy [target.professor = caller]   // Prof can remove staff members from his course

        remove(administers) constrainedBy [target.professor = caller] // Prof can remove himself from his own course

        // TA Requests
        
    }
    Course{
        create
        update(professor) constrainedBy [value = caller]
        update(name), add(staff) constrainedBy [self.professor = caller]        
        update(belongingTo) constrainedBy [self.professor.belongs = value]      

        // Delete course
        delete
        read(taRequests) constrainedBy [self.professor = caller]
        remove(taRequests) constrainedBy [self.professor = caller]

        update(maxCapacity) constrainedBy [self.professor = caller and
                value >= self.currStudents->size()]
    }   
    Department{
        add(offers) constrainedBy [self = caller.belongs] // A prof can only add a course to a department he belongs too

        remove(offers) constrainedBy [target.professor = caller]    // Prof can only remove his own courses from department
    }
    FinalGrade{
        create
        read(student) constrainedBy [caller.administers -> includes(self.course)]
        delete constrainedBy [caller.administers->includes(self.course)]

        update(course) constrainedBy [caller.administers->includes(value)]       // Prof can only link a final grade to a course he is administering himself
        update(value), update(student) constrainedBy [self.course.professor = caller]
    }
    ProvisionalGrade{
        delete constrainedBy [caller.administers->includes(self.course)]
    }
    TeachRequest{
        delete constrainedBy [caller.administers->includes(self.course)]
        read(ta) constrainedBy [self.course.professor = caller]
    }

}
role ADMIN {
    Person{
        create //constrainedBy [Person.allInstances()->forAll(c|c.username <> $Name_TF.text$)] 
        read(name)
        read(surname)
        read(username)
        read(password)
        read(belongs)
        update(belongs)
    }
    Course{
        read(name)
        read(maxCapacity)
        update(maxCapacity) constrainedBy [value >= self.maxCapacity]
        read(belongingTo)
        read(professor)
        read(staff)
        read(currStudents)
        read(pastStudents)
    }
    Department{ 
        create
        read
        update
    }
    FinalGrade{
        read // final grades are only for past users, so this is fine i guess
    }
    ProvisionalGrade{
    }
    TeachRequest{
    }
}